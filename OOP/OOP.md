# OOP - объектно-ориентированное программирование

**Объектно-ориентированное программирование (ООП)** — это подход, при котором программа рассматривается как набор объектов, 
взаимодействующих друг с другом. У каждого есть свойства и поведение. Основой объектно-ориентированного программирования (ООП) является понятие объект. Его суть
состоит в том, что объект объединяет в себе структуры данных и характерные только для него процедуры
(методы) их обработки. Такой подход полностью меняет стиль программирования, он заключается в
отображении физических объектов реального мира на программную среду. 

В свое время программирование выглядело вот так:
```javascript
var a = 1;
if (a > 0) {goto(4)} else {(goto(5)}
if (a > 3) goto(7)
```
Основные проблемы такого кода: 
+ Программы становятся сложнее, кода становится больше, читабельность уменьшается.
+ Поддерживать и развивать такой код крайне сложно.

**Структурное или процедурное программирование**:

+ В структурном программировании инструкции могут образовывать иерархии (можно вкладывать if в if).
  + Появляются конструкции циклов, которые позволяют создавать блоки. Необходимость goto отпадает.
```javascript
if (a > 0) {
    if (a < 3) {
    
    }
}
```
+ Появились процедуры - подпрограммы, в них описывается конкретный код и с помощью процедуры он вызывается с определенными входными данными.
+ В JS процедуры - это обычные функции. Благодаря этому, то, что раньше делали с помощью goto, теперь намного удобнее и лучше поддерживается
```javascript
function foo() {
    if (a > 0) {
        if (a < 3) {
    
        }
    }
}
    
foo()
foo()
```

В процедурном (структурном) программировании - программа строится из структурных блоков, блоков ветвления, циклов и из множества подпрограмм (процедур), которые выполняют определенные действия, а также могут вызывать внутри себя другие подпрограммы.
В нем очень четко разделено поведение: процедуры и сами данные.
```javascript
const jhon = {
    name: 'Jhon',
    age: 23
}

const bob = {
    name: 'Bob',
    age: 45
}

function showUserInfo(user) {
    console.log(`Name: ${user.name}; Age: ${user.age}`)
}

showUserInfo(jhon)
showUserInfo(bob)
```

**Основные проблемы такого подхода:**
1. Большое количество подпрограмм в глобальном пространстве;
2. Процедуры имеют полный доступ к данным и может поменять свойства;
3. Если в языке нет возможности перегрузки параметров, то может быть куча функций с похожим функционалом
4. Писать параллельные вычисления может быть очень сложно
5. Чем будет больше кода, тем больше будут возникать новые проблемы.


Для решения этиъх проблем появилось объектно-ориентированное программирование.

## ООП
Объект - это некоторая сущность, которая объединяет в себе как данные, так и поведение. Сами данные хранятся в свойствах, а поведение в методах.
**Базовые концепции**:
1. **ИНКАПСУЛЯЦИЯ** - объединение. Ввели формальный контракт между данными и их поведением. 
Поведение, которое может делать что-то с какой-то конкретной сущностью или конкретным набором данных, 
объединено с самими этими данными. Функция не глобальная, а ассоциирована с самим объектом с помощью ключевого слова this.
Метод вызывается либо с помощью точки, либо квадратных скобок (более универсальная точка). Значение контекста this берется либо слева от точки, либо от открывающей квадратной скобки
```javascript
const jhon = {
    name: 'Jhon',
    age: 28,
    showUserInfo() {
        console.log(`Name: ${this.name}; Age: ${this.age}`)
    }
}

jhon.showUserInfo()
jhon['showUserInfo']()
```

Так как контекст берется слева от точки или от открывающей квадратной скобки, то такая запись не выведет то, что ожидается (jhon.name и jhon.age):
```javascript
const f = jhon.showUserInfo
f()
```
Так произойдет, потому что функция вызвана без какого-либо контекста (нет точки, квадратных скобок), а раз этого нет, то this не понятно на что ссылается.
Есть два варианта, что может произойти:
+ this будет ссылаться на глобальный объект window;
+ Если добавить внутри функции showUserInfo "use strict" - означат использовать актуальный стандарт JS, в котором регламентировано, что this надо пробрасывать явно, так как здесь есть нарушение обратной совместимости.
То в таком случае this будет undefined, что вызовет ошибку, потому что у undefined нет таких свойств как name и age (у undefined вообще нет никаких свойств)

### THIS - неявный аргумент функции, который пробрасывают с помощью точки или квадратных скобок. он определяется в момент вызова функции.
У стрелочных функций нет неявного аргумента THIS.

```javascript
const a = () => {
    console.log(this)
} 

a() // будет выведен глобальный this, так как у стрелочной функции нет своего this

function Bla(self) {
    console.log(self) // выводится в консоль аргумент, который передали
    
    function BlaArrow() {
        console.log(self)
    }
    
    BlaArrow() // покажется self, который есть на уровень выше, так как нет проброса 
}

// Вызов функции bla покажет true, так как контекст будет браться из уровня выше (const that = this)
function Foo() {
    const that = this;
    const bla = () => {
      console.log(this === that)
    }
    bla()
}
// Вызов этой функции покажет false, так как this будет браться с глобального уровня
const bla = () => {
  console.log(this === that)
}
```

Стрелочные функции нужны для того, чтобы обращаться на уровень выше:
```javascript
class Foo {
    e = 1;
    
    bla() {
        const helper = () => {
            this.e = 2;
        }
        helper() // возьмет this у родительского окружения
    }
}
```

Также инкапсуляция позволила ввести сокрытие данных. 
Ввели формальный контракт, что какие-то методы и свойства можно вызывать снаружи, а какие-то нет, так как они являются приватными.
1. Ключевое слово **private** (на уровне TS). Благодаря ему невозможно обратиться снаружи к методу или свойству.
2. Ключевое слово **protected**. Снаружи мы не можем вызывать этот метод, но можем использовать при наследовании и как-то ссылаться на этот метод.
```javascript
class foo {
    private bla = 1
    protected bar() {
        // ...
    }
}

console.log(new Foo().bla)

class Baz extends Foo {
    b() {
        this.bar()
    }
}
```

В JS появились другие обозначения для приватных полей (также нельзя обращаться к ним вне класса).
К приватному полю можно обратиться только через точку:
```javascript
class foo {
    #bla = 1
    bar() {
        this.#bla = 3
    }
}

console.log(new Foo().#bla) // не получится так обратиться, так как  это приватное поле
```

2. **Наследование** - делегировать часть свойств и методов другим объектам.
У объекта могут быть объекты-прообразы, в которых хранится часть свойств. Если искомое свойство или метод не найдено в текущем объекте, то оно будет искаться в объекте прообразе и так далее, пока цепочка не завершится.
Такие объекты прообразы в JS называются прототипами. В JS прототипное наследование. Прототип - это обычный объект со своими методами и свойствами.
Наследование позволяет переиспользовать код, так как мы выделили какую-то родительскую сущность и от нее отнаследовали свойства и методы.
```javascript
const user = {
    showUserInfo() {
        console.log(`Name: ${this.name}; Age: ${this.age}`)
    }
}
const jhon = {
    name: 'Jhon',
    age: 28,
    __proto__: user
}

const bob = {
    name: 'Jhon',
    age: 28,
    __proto__: user
}

bob.showUserInfo()
```

Иерархия наследования может быть очень глубокой.
```javascript
function foo() {}

foo.__proto__ === Function.prototype
Function.prototype === Object.prototype
```
**Минусы наследования**:
+ Чем цепочка наследований становится длиннее, тем сложнее становится за этим следить (огромное вертикальное наследование);
+ Появляются большие классы, которые содержат всего много разных методов и свойств, это становится сложно поддерживать;
+ Сложнее вносить изменения, так как можно поломать, что-то в своих дочерних классах;
+ Сложнее добавлять какие-то вещи, которые нужны только конкретным компонентам;
+ Больше про написание систем, которые почти не меняются.

3. Наследование вытекает в **Полиморфизм подтипов**. Вместо конкретного объекта типа user, можно пробрасывать и его потомки. 
```javascript
function foo(user) {
    if (obj === user || user.isPrototypeOf(obj)) {
        obj.showUserInfo()
    }
}

foo(bob)
```

**Принцип подстановки Барбары Лисков** - любой тип может быть заменен его подтипом, и программа не должна сломаться (переопределять методы не стоит, так как может сломаться программа).


**Плюсы ООП**:
+ Не так засоряется глобальное пространство, вместо выдачи новых имен функциям, можно называть одинаково в разных объектах, реализовывать по-разному.
+ Сокрытие данных


**Семантика поиска и записи свойства в объект с прототипом**:
С помощью деструктуризации вынимаем все свойства из объекта и записываем их в b. 
В паммяти выделили такое же количество памяти для хранения свойств, а потом прошли по всем этим свойствам и скопировали из одних ячеек памяти в другие.
```javascript
const a = {
    a: 1,
    b: 2,
    c: 3
}

const b = {...a}
```

Вместо такого варианта, который может занять много памяти, если объект достаточно большой, и времени для обработки, 
можно применить другой прием:
```javascript
const a = {
    a: 1,
    b: 2,
    c: 3
}

const b = {__proto__: a}

// const b = Object.create(a) - используется этот вариант, а не с прото, по сути он это и делает

console.log(b.a) // 1

b.c = 34

console.log(b.c) // 34
console.log(a.c) // 3
```

По сути было выделено какое-то минимальное количество памяти для создания пустого объект и ссылки proto. При чтении объекта можно получить свойства, так как они будут браться из прототипа а,
но если начать их менять, то оно поменяется не в объекте прототипе, а уже в самом объекте, с которым работаем.
Копирование физически происходит в момент записи.







  