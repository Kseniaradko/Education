# Классы и ООП
1. **Класс** - эо формализация типа объекта, в нем описано какие свойства и методы будут, от кого он наследуется.
   Это по сути печатный станок, от которого создаются объекты с помощью слова new (new User()). Классы были созданы для конкретизации создаваемых типов, для интеграции средств статического анализа кода.

2. Объекты, созданные с помощью класса, называются экземплярами класса или instance.
   Метод instanceof позволяет проверить является ли объект экземпляром этого класса: obj instanceof User.
   Если у объекта в цепочке прототипов есть этот класс, то будет true, иначе false.
   Данный метод позволил уйти от так называемой утиной типизации (если что-то летает как утка, выглядит как утка и крякает как утка, то это утка: поэтому утиная типизация): typeof obj.name === 'string' && typeof obj.age === 'number'

3. В классах также используется наследование. Можно наследоваться и от нативных классов!!!
   Чтобы класс унаследовал свойства и методы у другого класса, то используется слово extends.
   Такие классы унаследовали все методы и свойства у своего родителя, также сюда можно добавлять свои свойства и методы. Также можно переписывать (overwrite) уже существующие методы (showUserInfo).
   В этих же методах, кроме переписывания, можно вызывать и родительскую реализацию с помощью слова super
   Если говорить о конструкторе, то если необходимо переписать этот метод, то ОБЯЗАТЕЛЬНО надо вызывать родительский метод (super(name, age)).

```javascript
// 1. Класс
class User {
    name;
    age;
    
    constructor(name, age) {
        this.name = name
        this.age = age
    }

    showUserInfo() {
        console.log(`Name: ${this.name}; Age: ${this.age}`)
    }
}

// 2. Создание объектов от класса
const jhon = new User('Jhon', 45)
const bob = new User('Bob', 73)
    
// Прототип у jhon и bob будет User
Object.getPrototypeOf(jhon) === User.prototype

// Свойство instanceof
function bla(obj) {
    if (obj instanceof User) {
        obj.showUserInfo()
    }
}

// 3. Наследование класса от родителя с помощью слова extends
class Manager extends User {
    role = 'manager';

    function
// Переписывание родительских методов с помощью ключевого слова super.
    constructor(name, age) {
        super(name, age);
        this.role = 'manager';
    }

    showUserInfo() {
        console.log('I am manager')
        super.showUserInfo()
    }
// Добавление новых методов в класс.
    deleteUser(id) {
        // ...
    }
}
```

4. Ключевое слово super может использоваться не только в классах, но и в объектах.
   Но оно может использоваться только в теле метода. Обязательно записывать как функцию.
   Ссылается оно статически на значение __proto__, которое в текущем литерале объекта используется.
```javascript
const bla = {
    __proto__: {
        foo() {
            return 1;
        }
    },
    
    foo() {
        return super.foo() // вернет 1
    }
}
// Так нельзя, так как super появилась в ES6. 
// До этого не было ни короткой записи методов, как выше, ни super.
const bla1 = {
    foo: function() {
        super
    }
}
```

5. Статические методы и свойства:
+ Можно вызвать без создания экземпляра класса: Foo.a
+ Объявляются с помощью ключевого слова static;
+ При наследовании также передаются дочерним классам;
+ Можно переписать такие методы и свойства.
```javascript
class Foo {
    static a = 1;
    
    static bla() {
        
    }
}
```
Обычно статические методы используются для реализации функций, принадлежащих классу целиком, вообще, 
и при этом не относящимся к каким-то отдельным объектам.
Например, есть объекты статей Article, и нужна функция для их сравнения.
```javascript
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

// использование
let articles = [
  new Article("HTML", new Date(2019, 1, 1)),
  new Article("CSS", new Date(2019, 0, 1)),
  new Article("JavaScript", new Date(2019, 11, 1))
];

articles.sort(Article.compare);

alert( articles[0].title ); // CSS
```
Здесь метод Article.compare стоит «над» статьями, как средство для их сравнения. 
Это метод не отдельной статьи, а всего класса.